<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Goss · Encrypted</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <link href="https://fonts.googleapis.com/css2?family=Archivo:ital,wdth,wght@0,100..900;1,100..900&family=JetBrains+Mono:wght@400;500;700;800&display=swap" rel="stylesheet">

  <style>
    :root {
      /* Premium Panic Palette */
      --bg-gradient-start: #FFB300; /* Amber Warning */
      --bg-gradient-end: #FF3D00;   /* Deep Orange */
      --accent: #D50000;            /* Alarm Red */
      --ink: #121212;               /* Soft Black */
      --paper: #F4F1EA;             /* Archival Paper */
      --paper-shadow: #BEBDB8;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0; padding: 0; }

    body {
      background-color: var(--bg-gradient-start);
      background-image: linear-gradient(145deg, var(--bg-gradient-start), var(--bg-gradient-end));
      color: var(--ink);
      font-family: "JetBrains Mono", monospace;
      height: 100dvh; 
      width: 100vw;
      display: flex;
      flex-direction: column;
      overflow: hidden; 
    }

    /* --- ATMOSPHERE --- */
    .grain {
      position: fixed; inset: 0; pointer-events: none; z-index: 2; opacity: 0.12;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
    }
    .vignette {
      position: fixed; inset: 0; pointer-events: none; z-index: 3;
      background: radial-gradient(circle, transparent 30%, rgba(0,0,0,0.5) 100%);
    }

    /* --- HEADER --- */
    .top {
      flex: 0 0 auto; 
      background: var(--paper); 
      border-bottom: 4px solid var(--ink);
      padding: 12px 16px; 
      z-index: 10; 
      display: grid; 
      grid-template-columns: auto 1fr auto;
      align-items: center; 
      gap: 12px; 
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }

    .nuke-btn {
      background: var(--accent); color: white; border: 2px solid var(--ink);
      font-family: "Archivo", sans-serif; font-weight: 900; font-size: 11px;
      padding: 8px 12px; text-transform: uppercase; box-shadow: 3px 3px 0 var(--ink);
      cursor: pointer; display: flex; align-items: center; gap: 6px; white-space: nowrap;
      letter-spacing: 0.05em; transition: all 0.1s;
    }
    .nuke-btn:active { transform: translate(2px, 2px); box-shadow: none; }

    .timer-display {
      justify-self: center;
      text-align: center; font-family: "JetBrains Mono", monospace; font-weight: 800;
      font-size: 16px; color: var(--accent);
      background: rgba(0,0,0,0.05); padding: 4px 12px; min-width: 80px;
      border-radius: 4px; border: 1px solid rgba(0,0,0,0.1);
    }

    .back-btn {
      justify-self: end; text-decoration: none; font-size: 11px; font-weight: 800;
      color: var(--ink); text-transform: uppercase; border-bottom: 2px solid var(--ink);
    }

    /* --- MARQUEE --- */
    .participants-marquee {
      background: var(--ink); color: var(--paper); font-size: 10px; font-weight: 700;
      padding: 6px 0; white-space: nowrap; overflow: hidden; text-transform: uppercase; flex: 0 0 auto;
      border-bottom: 2px solid var(--accent); z-index: 5;
    }
    .marquee-content {
      display: inline-block; padding-left: 100%; animation: scroll-left 20s linear infinite;
    }
    @keyframes scroll-left { 0% { transform: translateX(0); } 100% { transform: translateX(-100%); } }

    /* --- CHAT LOG --- */
    .log {
      flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column;
      gap: 16px; position: relative; z-index: 4; scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch; padding-bottom: 20px;
    }

    .message {
      max-width: 85%; padding: 14px 16px; position: relative;
      border: 3px solid var(--ink); 
      animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    
    /* THEM: Paper Note Style */
    .message.them { 
      align-self: flex-start; 
      background: var(--paper); 
      color: var(--ink); 
      box-shadow: 6px 6px 0 rgba(0,0,0,0.15);
      border-bottom-left-radius: 0;
    }
    
    /* ME: Redacted/Black Ops Style */
    .message.me { 
      align-self: flex-end; 
      background: var(--ink); 
      color: var(--paper); 
      border-color: var(--ink); 
      box-shadow: 6px 6px 0 var(--accent);
      border-bottom-right-radius: 0;
    }
    
    .from { 
      font-family: "Archivo", sans-serif;
      font-size: 9px; font-weight: 800; text-transform: uppercase; 
      margin-bottom: 6px; letter-spacing: 0.1em; opacity: 0.7; 
    }
    .message.me .from { color: var(--accent); opacity: 1; text-align: right; }
    .text { font-size: 14px; line-height: 1.5; font-weight: 500; white-space: pre-wrap; word-wrap: break-word; }

    /* --- INPUT AREA --- */
    .input-area {
      flex: 0 0 auto; background: var(--paper); border-top: 4px solid var(--ink);
      padding: 12px 16px; z-index: 999; display: flex; gap: 12px; align-items: flex-end;
      padding-bottom: max(12px, env(safe-area-inset-bottom)); 
      box-shadow: 0 -10px 40px rgba(0,0,0,0.3);
    }
    
    .input-area textarea {
      flex: 1; background: #FFF; border: 2px solid var(--ink); padding: 12px;
      color: var(--ink); font-family: "JetBrains Mono", monospace; font-size: 16px;
      resize: none; height: 50px; outline: none; border-radius: 0;
      transition: all 0.2s;
    }
    .input-area textarea:focus { box-shadow: 4px 4px 0 var(--ink); transform: translate(-2px, -2px); }

    .send-btn {
      width: 60px; height: 50px; background: var(--ink); border: 2px solid var(--ink);
      color: var(--paper); font-family: "Archivo", sans-serif; font-weight: 900; font-size: 12px;
      text-transform: uppercase; cursor: pointer; box-shadow: 4px 4px 0 var(--accent); flex-shrink: 0;
      transition: all 0.1s;
    }
    .send-btn:active { transform: translate(2px, 2px); box-shadow: none; }

    @keyframes popIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }

    /* --- NUKE UI --- */
    .overlay {
      position: fixed; inset: 0; background: rgba(18, 18, 18, 0.95);
      backdrop-filter: blur(4px); z-index: 2000; opacity: 0; pointer-events: none; transition: opacity 0.3s;
    }
    .overlay.active { opacity: 1; pointer-events: auto; }

    .bottom-sheet {
      position: fixed; left: 0; right: 0; bottom: -100%; background: var(--paper);
      border-top: 4px solid var(--ink); padding: 32px 24px 48px; z-index: 2001;
      transition: bottom 0.3s cubic-bezier(0.19, 1, 0.22, 1); box-shadow: 0 -20px 50px rgba(0,0,0,0.8);
    }
    .bottom-sheet.active { bottom: 0; }

    .bs-title { font-family: "Archivo", sans-serif; font-size: 24px; font-weight: 900; font-style: italic; text-transform: uppercase; margin-bottom: 12px; color: var(--accent); }
    .bs-text { font-size: 14px; font-weight: 500; margin-bottom: 24px; line-height: 1.5; color: var(--ink); }

    .bs-btn-danger {
      width: 100%; padding: 16px; background: var(--accent); color: white; border: 3px solid var(--ink);
      font-weight: 800; font-family: "Archivo", sans-serif; text-transform: uppercase; letter-spacing: 0.1em;
      box-shadow: 6px 6px 0 var(--ink); cursor: pointer; margin-bottom: 8px;
    }
    .bs-btn-danger:active:not([disabled]) { transform: translate(2px, 2px); box-shadow: none; }
    .bs-btn-danger[disabled] { opacity: 0.6; pointer-events: none; filter: grayscale(1); }

    .bs-btn-cancel {
      width: 100%; background: transparent; border: none; padding: 12px;
      text-decoration: underline; font-weight: 700; cursor: pointer; color: var(--ink);
      text-transform: uppercase; font-size: 10px;
    }
    
    .waiting-box {
      border: 2px dashed var(--ink); padding: 16px; text-align: center;
      background: rgba(0,0,0,0.05); font-weight: 700; font-size: 12px; margin-bottom: 12px;
      text-transform: uppercase; letter-spacing: 0.05em;
    }
  </style>
</head>

<body>
  <div class="grain"></div>
  <div class="vignette"></div>

  <div class="top">
    <button class="nuke-btn" onclick="initiateNuke()">☢️ NUKE CHAT</button>
    <div class="timer-display" id="timer">--:--</div>
    <a href="rant.html" class="back-btn">EXIT FILE</a>
  </div>

  <div class="participants-marquee">
    <div class="marquee-content" id="participantsText">LOADING SECURE CONNECTION...</div>
  </div>

  <div id="messages" class="log"></div>

  <div class="input-area">
    <textarea id="msg" placeholder="Add to the record..." autofocus></textarea>
    <button class="send-btn" onclick="send()">Send</button>
  </div>

  <div class="overlay" id="sheetOverlay"></div>
  <div class="bottom-sheet" id="nukeSheet"></div>

  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <script>
    const CHAT_TTL_MINUTES = 15;
    const firebaseConfig = {
      apiKey: "AIzaSyDqwklNFPF09IiE1Gh6_ckJr2Jz6F0V2f8", 
      authDomain: "rant-2me.firebaseapp.com",
      projectId: "rant-2me"
    };

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    const params = new URLSearchParams(window.location.search);
    const chatId = params.get("chatId");
    
    // Global State for efficiency
    let currentChatData = null; 
    let timerInterval = null;

    // Force focus logic
    window.onload = function() {
        setTimeout(() => {
            const input = document.getElementById("msg");
            if(input) input.focus();
        }, 500);
    };

    auth.onAuthStateChanged(user => {
      if (!user || !chatId) {
        window.location.href = "index.html";
        return;
      }

      // 1. Listen to Chat Metadata
      db.collection("chats").doc(chatId).onSnapshot(doc => {
        // --- KEY DESTRUCTION CHECK ---
        if (!doc.exists) {
          console.log("Chat deleted. Redirecting...");
          // Small delay to ensure browser handles the redirect smoothly
          setTimeout(() => {
             window.location.href = "rant.html";
          }, 100);
          return;
        }

        const chat = doc.data();
        currentChatData = chat; 

        // Security Check
        if (!chat.users.includes(user.email)) {
          window.location.href = "rant.html"; return;
        }

        // UI Updates
        document.getElementById("participantsText").innerText = 
          `SECURE CONNECTION: ${chat.users.join('  <->  ')}   ///   ENCRYPTED`;

        startTimer(chat.createdAt);
        handleNukeState(chat, user.email);

        // One-time Seed
        if (chat.seed) hydrateSeed(chat);
      });

      // 2. Listen to Messages
      db.collection("chats").doc(chatId).collection("messages")
        .orderBy("createdAt")
        .onSnapshot(snapshot => {
          const container = document.getElementById("messages");
          container.innerHTML = "";
          
          snapshot.forEach(doc => {
            const m = doc.data();
            const isMe = m.from === user.email;
            container.innerHTML += `
              <div class="message ${isMe ? "me" : "them"}">
                <div class="from">${isMe ? "YOU" : "THEY"}</div>
                <div class="text">${m.text}</div>
              </div>
            `;
          });
          container.scrollTop = container.scrollHeight;
        });
    });

    // --- LOGIC ---

    function hydrateSeed(chat) {
       db.collection("chats").doc(chatId).collection("messages").limit(1).get().then(snap => {
         if(snap.empty && chat.seed) {
           const batch = db.batch();
           chat.seed.forEach(m => {
             const ref = db.collection("chats").doc(chatId).collection("messages").doc();
             batch.set(ref, { from: m.from, text: m.text, createdAt: m.createdAt });
           });
           batch.update(db.collection("chats").doc(chatId), { seed: firebase.firestore.FieldValue.delete() });
           batch.commit();
         }
       });
    }

    function startTimer(timestamp) {
      if(!timestamp) return;
      if(timerInterval) clearInterval(timerInterval); 

      const update = () => {
        const now = new Date();
        const created = timestamp.toDate();
        const expires = new Date(created.getTime() + CHAT_TTL_MINUTES * 60000);
        const diff = expires - now;

        if (diff <= 0) {
          clearInterval(timerInterval);
          document.getElementById("timer").innerText = "00:00";
        } else {
          const mins = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
          const secs = Math.floor((diff % (1000 * 60)) / 1000);
          document.getElementById("timer").innerText = 
            `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }
      };
      
      update(); 
      timerInterval = setInterval(update, 1000);
    }

    // --- NUKE LOGIC (FIXED) ---

    function handleNukeState(chat, myEmail) {
      const sheet = document.getElementById("nukeSheet");
      const overlay = document.getElementById("sheetOverlay");
      
      if (chat.nukeRequest) {
        overlay.classList.add("active");
        sheet.classList.add("active");

        // Prevent UI flickering if already showing the correct state
        const newState = chat.nukeRequest === myEmail ? "WAITING" : "REQUEST";
        if (sheet.dataset.state === newState) return;
        sheet.dataset.state = newState;

        if (chat.nukeRequest === myEmail) {
          // I AM THE SENDER
          sheet.innerHTML = `
            <div class="bs-title">AWAITING CONFIRMATION</div>
            <div class="bs-text">
              You have armed the destruction sequence. Waiting for the other person to turn their key.
            </div>
            <div class="waiting-box">WAITING FOR PARTNER...</div>
            <button class="bs-btn-cancel" onclick="cancelNuke()">CANCEL REQUEST</button>
          `;
        } else {
          // I AM THE RECEIVER -> ACTION REQUIRED
          sheet.innerHTML = `
            <div class="bs-title">⚠️ DESTRUCTION REQUEST</div>
            <div class="bs-text">
              Your partner wants to nuke this chat. If you agree, all records will be permanently erased immediately.
            </div>
            <button id="confirmBtn" class="bs-btn-danger" onclick="confirmDestruction()">AGREE & DESTROY</button>
            <button class="bs-btn-cancel" onclick="cancelNuke()">REJECT</button>
          `;
        }
      } else {
        // Only close if we are not initiating locally (prevents closing the INIT screen)
        if (sheet.dataset.state === "WAITING" || sheet.dataset.state === "REQUEST") {
            overlay.classList.remove("active");
            sheet.classList.remove("active");
            sheet.dataset.state = "NONE";
        }
      }
    }

    function initiateNuke() {
      if(!currentChatData || !auth.currentUser) return; // Added auth safety check

      const myEmail = auth.currentUser.email;
      const otherUsers = currentChatData.users.filter(u => u !== myEmail);

      if(otherUsers.length === 0) {
          // Self Chat: Instant Kill
          confirmDestruction();
      } else {
          // Real Chat: Show Local Prompt
          const sheet = document.getElementById("nukeSheet");
          const overlay = document.getElementById("sheetOverlay");
          
          // Don't overwrite if a request is already coming in from partner
          if(currentChatData.nukeRequest) return;

          sheet.dataset.state = "INIT";
          sheet.innerHTML = `
            <div class="bs-title">INITIATE DESTRUCTION?</div>
            <div class="bs-text">
              This sends a request to your partner. If they agree, this chat vanishes for both of you instantly.
            </div>
            <button id="armBtn" class="bs-btn-danger" onclick="sendNukeRequest()">SEND DESTRUCT SIGNAL</button>
            <button class="bs-btn-cancel" onclick="closeSheet()">NEVER MIND</button>
          `;
          
          overlay.classList.add("active");
          sheet.classList.add("active");
      }
    }

    function closeSheet() {
      document.getElementById("sheetOverlay").classList.remove("active");
      document.getElementById("nukeSheet").classList.remove("active");
      document.getElementById("nukeSheet").dataset.state = "NONE";
    }

    function sendNukeRequest() {
      const btn = document.getElementById("armBtn");
      if(btn) {
          btn.innerText = "ARMING...";
          btn.disabled = true;
      }
      
      // We do not check auth here as it's checked in initiateNuke
      db.collection("chats").doc(chatId).update({
        nukeRequest: auth.currentUser.email
      }).catch(err => {
         console.error("Error sending nuke request:", err);
         alert("Could not arm nuke: " + err.message);
         if(btn) { btn.innerText = "SEND DESTRUCT SIGNAL"; btn.disabled = false; }
      });
    }

    function cancelNuke() {
      db.collection("chats").doc(chatId).update({
        nukeRequest: firebase.firestore.FieldValue.delete()
      });
      // The snapshot listener will handle closing the sheet
    }

    function confirmDestruction() {
      console.log("Confirming destruction for chat: " + chatId);
      
      const btn = document.getElementById("confirmBtn");
      if(btn) {
          btn.innerText = "ERASING DATA...";
          btn.disabled = true;
      } else {
          // Fallback UI for self-chat
          const sheet = document.getElementById("nukeSheet");
          const overlay = document.getElementById("sheetOverlay");
          overlay.classList.add("active");
          sheet.classList.add("active");
          sheet.innerHTML = `<div class="bs-title">GOODBYE.</div><div class="waiting-box">ERASING RECORDS...</div>`;
      }

      // 1. Fetch messages to delete them
      db.collection("chats").doc(chatId).collection("messages").get()
        .then(snapshot => {
            const batch = db.batch();
            
            // 2. Add all messages to batch (Limit 450 to be safe under 500 op limit)
            if(!snapshot.empty) {
                snapshot.docs.slice(0, 450).forEach(doc => {
                    batch.delete(doc.ref);
                });
            }

            // 3. Add Chat Document to batch
            const chatRef = db.collection("chats").doc(chatId);
            batch.delete(chatRef);

            // 4. Commit Atomically
            return batch.commit();
        })
        .then(() => {
           console.log("Nuke complete.");
           // IMPORTANT FIX: Do NOT manually redirect here. 
           // The onSnapshot listener on 'chats' will detect the deletion and redirect.
           // This prevents race conditions between the commit success and the snapshot firing.
        })
        .catch((error) => {
           console.error("Nuke failed: ", error);
           alert("NUKE FAILED: " + error.message);
           if(btn) {
               btn.innerText = "AGREE & DESTROY";
               btn.disabled = false;
           }
        });
    }

    // --- MESSAGING ---

    function send() {
      const input = document.getElementById("msg");
      const text = input.value.trim();
      if (!text) return;
      if (text.length > 2000) return;

      db.collection("chats").doc(chatId).collection("messages").add({
        from: auth.currentUser.email,
        text,
        createdAt: new Date()
      });
      input.value = "";
      input.focus();
    }

    document.getElementById("msg").addEventListener("keydown", function(e) {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        send();
      }
    });

  </script>
</body>
</html>